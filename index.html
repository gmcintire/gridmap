<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GridMap by W5ISP - Maidenhead Grid Square Map</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' fill='%23228B22'/%3E%3Cpath d='M0 16h32M16 0v32' stroke='%23fff' stroke-width='2'/%3E%3Cpath d='M0 8h32M0 24h32M8 0v32M24 0v32' stroke='%23fff' stroke-width='0.5' opacity='0.4'/%3E%3C/svg%3E">
    <link rel="stylesheet" href="leaflet.css" />
    <style>
        :root {
            --grid-color: #E63946;
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-overlay: rgba(0, 0, 0, 0.6);
            --bg-toast: rgba(0, 0, 0, 0.8);
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #map {
            height: 100vh;
            width: 100vw;
        }

        #top-bar {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 6px 8px 6px 16px;
            border-radius: 8px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 12px;
            white-space: nowrap;
        }

        #grid-display {
            cursor: pointer;
            user-select: none;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            border-radius: 6px;
            transition: background 0.15s;
        }

        #grid-display:hover {
            background: #f0f0f0;
        }

        #grid-display .copy-hint {
            font-size: 11px;
            color: #999;
            font-weight: normal;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .bar-divider {
            width: 1px;
            height: 24px;
            background: #ddd;
        }

        #grid-search {
            display: flex;
            gap: 4px;
        }

        #grid-search input {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            width: 100px;
            text-transform: uppercase;
            outline: none;
            background: #f8f8f8;
        }

        #grid-search input:focus {
            border-color: #2563eb;
            background: white;
        }

        #grid-search button {
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            background: var(--primary-color);
            color: white;
            cursor: pointer;
            font-size: 13px;
        }

        #grid-search button:hover {
            background: var(--primary-hover);
        }

        #precision-display {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-overlay);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            z-index: 1000;
            font-size: 12px;
            pointer-events: none;
        }

        #toast {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-toast);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            z-index: 1001;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        #toast.visible {
            opacity: 1;
        }

        .grid-label {
            background: none !important;
            border: none !important;
        }

        #callsign {
            position: fixed;
            bottom: 8px;
            left: 10px;
            z-index: 1000;
            font-size: 12px;
        }

        #callsign a {
            color: rgba(0, 0, 0, 0.5);
            text-decoration: none;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
        }

        #callsign a:hover {
            color: rgba(0, 0, 0, 0.8);
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>

<body>
    <div id="top-bar">
        <div id="grid-display" role="button" tabindex="0" aria-label="Click to copy current grid square">
            <span id="grid-text">Current Grid: --</span>
            <span class="copy-hint">click to copy</span>
        </div>
        <div class="bar-divider"></div>
        <div id="grid-search">
            <label for="search-input" class="visually-hidden">Enter grid square</label>
            <input type="text" id="search-input" placeholder="FN31pr" maxlength="8" aria-label="Enter grid square" />
            <button onclick="searchGrid()" aria-label="Go to grid square">Go</button>
        </div>
    </div>
    <div id="precision-display"></div>
    <div id="toast"></div>
    <div id="callsign"><a href="https://w5isp.com" target="_blank">by W5ISP</a></div>
    <div id="map"></div>

    <script src="leaflet.js"></script>
    <script>
        let map, marker;
        let firstFix = false;
        let toastTimeout;
        const gridSquares = L.layerGroup();

        // Toast notification (replaces alert())
        function showToast(message, duration = 2000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('visible');
            clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => toast.classList.remove('visible'), duration);
        }

        // Debounce utility
        function debounce(fn, delay) {
            let timer;
            return function (...args) {
                clearTimeout(timer);
                timer = setTimeout(() => fn.apply(this, args), delay);
            };
        }

        class GridSquare {
            constructor(lat, lon) {
                this.lat = lat;
                this.lon = this.normalizeLon(lon);
            }

            normalizeLon(lon) {
                lon = lon % 360;
                if (lon > 180) lon -= 360;
                else if (lon < -180) lon += 360;
                return lon;
            }

            encode(precision = 4) {
                const adjLon = this.lon + 180;
                const adjLat = this.lat + 90;

                let gridRef = '';

                // Field (first pair, base 18 A-R)
                gridRef += String.fromCharCode(65 + Math.floor(adjLon / 20));
                gridRef += String.fromCharCode(65 + Math.floor(adjLat / 10));

                // Square (second pair, base 10 0-9)
                gridRef += Math.floor((adjLon % 20) / 2);
                gridRef += Math.floor(adjLat % 10);

                if (precision > 4) {
                    // Subsquare (third pair, base 24 a-x)
                    const lonMin = (adjLon % 2) * 60;
                    const latMin = (adjLat % 1) * 60;
                    gridRef += String.fromCharCode(97 + Math.floor(lonMin / 5));
                    gridRef += String.fromCharCode(97 + Math.floor(latMin / 2.5));
                }

                if (precision > 6) {
                    // Extended square (fourth pair)
                    const lonSec = (adjLon % (5 / 60)) * 3600;
                    const latSec = (adjLat % (2.5 / 60)) * 3600;
                    gridRef += Math.floor(lonSec / 30);
                    gridRef += Math.floor(latSec / 15);
                }

                return gridRef;
            }

            static decode(grid) {
                grid = grid.substring(0, 2).toUpperCase() + grid.substring(2, 4) +
                    (grid.length > 4 ? grid.substring(4, 6).toLowerCase() : '') +
                    (grid.length > 6 ? grid.substring(6, 8) : '');

                const field1 = grid.charCodeAt(0) - 65;
                const field2 = grid.charCodeAt(1) - 65;

                const square1 = parseInt(grid[2]);
                const square2 = parseInt(grid[3]);

                let westLon = (field1 * 20) - 180 + (square1 * 2);
                let southLat = (field2 * 10) - 90 + square2;

                let width = 2;
                let height = 1;

                if (grid.length >= 6) {
                    const subsq1 = grid.charCodeAt(4) - 97;
                    const subsq2 = grid.charCodeAt(5) - 97;

                    westLon += subsq1 * 5 / 60;
                    southLat += subsq2 * 2.5 / 60;
                    width = 5 / 60;
                    height = 2.5 / 60;
                }

                if (grid.length >= 8) {
                    const ext1 = parseInt(grid[6]);
                    const ext2 = parseInt(grid[7]);

                    westLon += ext1 * 30 / 3600;
                    southLat += ext2 * 15 / 3600;
                    width = 30 / 3600;
                    height = 15 / 3600;
                }

                return {
                    west: westLon,
                    east: westLon + width,
                    south: southLat,
                    north: southLat + height,
                    center: {
                        lat: southLat + height / 2,
                        lon: westLon + width / 2
                    }
                };
            }

            static isValid(grid) {
                if (!grid || grid.length < 4 || grid.length % 2 !== 0 || grid.length > 8) return false;
                const c0 = grid.toUpperCase().charCodeAt(0);
                const c1 = grid.toUpperCase().charCodeAt(1);
                if (c0 < 65 || c0 > 82 || c1 < 65 || c1 > 82) return false;
                if (isNaN(parseInt(grid[2])) || isNaN(parseInt(grid[3]))) return false;
                if (grid.length >= 6) {
                    const c4 = grid.toLowerCase().charCodeAt(4);
                    const c5 = grid.toLowerCase().charCodeAt(5);
                    if (c4 < 97 || c4 > 120 || c5 < 97 || c5 > 120) return false;
                }
                if (grid.length >= 8) {
                    if (isNaN(parseInt(grid[6])) || isNaN(parseInt(grid[7]))) return false;
                }
                return true;
            }
        }

        function calculateGridSquare(lat, lon, extended = false) {
            const grid = new GridSquare(lat, lon);
            return grid.encode(extended ? 8 : 6);
        }

        function gridToCoordinates(grid) {
            return GridSquare.decode(grid);
        }

        function drawGridSquare(grid, precision, bounds) {
            if (grid.length < 4) return;

            const coords = gridToCoordinates(grid);

            if (coords.west > bounds.getEast() || coords.east < bounds.getWest() ||
                coords.south > bounds.getNorth() || coords.north < bounds.getSouth()) {
                return;
            }

            const detailed = precision >= 6;
            const extended = precision >= 8;

            const rectangle = L.rectangle([
                [coords.south, coords.west],
                [coords.north, coords.east]
            ], {
                color: "#E63946",
                weight: detailed ? 1 : 2,
                opacity: 0.8,
                fillOpacity: 0,
                interactive: false
            });

            gridSquares.addLayer(rectangle);

            // Only add labels if the square is large enough in pixels
            const sw = map.latLngToContainerPoint([coords.south, coords.west]);
            const ne = map.latLngToContainerPoint([coords.north, coords.east]);
            const pixelWidth = Math.abs(ne.x - sw.x);

            const minLabelWidth = detailed ? (extended ? 30 : 50) : 60;
            if (pixelWidth > minLabelWidth) {
                const displayLength = extended ? 8 : (detailed ? 6 : 4);
                const displayText = grid.substring(0, displayLength);
                const fontSize = extended ? '10' : (detailed ? '14' : '22');
                const iconWidth = extended ? 60 : (detailed ? 70 : 90);
                const iconHeight = extended ? 18 : (detailed ? 24 : 32);
                const iconAnchorX = extended ? 30 : (detailed ? 35 : 45);
                const iconAnchorY = extended ? 9 : (detailed ? 12 : 16);
                const label = L.divIcon({
                    className: 'grid-label',
                    html: `<div style="font-size: ${fontSize}px; font-weight: bold; color: white; text-shadow: 0 0 3px rgba(0,0,0,0.9), 0 0 3px rgba(0,0,0,0.9), 1px 1px 2px rgba(0,0,0,0.8), -1px -1px 2px rgba(0,0,0,0.8); white-space: nowrap;">${displayText}</div>`,
                    iconSize: [iconWidth, iconHeight],
                    iconAnchor: [iconAnchorX, iconAnchorY]
                });

                const labelMarker = L.marker([coords.center.lat, coords.center.lon], {
                    icon: label,
                    interactive: false
                });

                gridSquares.addLayer(labelMarker);
            }
        }

        // Grid search
        function searchGrid() {
            const input = document.getElementById('search-input').value.trim();
            if (!input) return;

            if (!GridSquare.isValid(input)) {
                showToast('Invalid grid square format', 3000);
                return;
            }

            const coords = GridSquare.decode(input);
            const zoomLevel = input.length >= 8 ? 16 : input.length >= 6 ? 13 : 10;
            map.flyTo([coords.center.lat, coords.center.lon], zoomLevel);

            const normalized = input.substring(0, 2).toUpperCase() + input.substring(2, 4) +
                (input.length > 4 ? input.substring(4, 6).toLowerCase() : '') +
                (input.length > 6 ? input.substring(6, 8) : '');
            showToast(`Flying to ${normalized}`);
        }

        // Click-to-copy
        function copyGridToClipboard() {
            const text = document.getElementById('grid-text').textContent;
            const grid = text.replace('Current Grid: ', '');
            if (grid && grid !== '--') {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(grid).then(() => {
                        showToast('Copied: ' + grid);
                    }).catch(() => {
                        fallbackCopy(grid);
                    });
                } else {
                    fallbackCopy(grid);
                }
            }
        }

        document.getElementById('grid-display').addEventListener('click', copyGridToClipboard);
        document.getElementById('grid-display').addEventListener('keydown', function (e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                copyGridToClipboard();
            }
        });

        function fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showToast('Copied: ' + text);
            } catch (e) {
                showToast('Copy failed');
            }
            document.body.removeChild(textArea);
        }

        // Search on Enter key
        document.getElementById('search-input').addEventListener('keydown', function (e) {
            if (e.key === 'Enter') searchGrid();
        });

        // Initialize map
        function initMap() {
            try {
                map = L.map('map', { worldCopyJump: true }).setView([0, 0], 2);
            } catch (e) {
                showToast('Failed to initialize map: ' + e.message, 5000);
                return;
            }

            // Tile layers
            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors',
                maxZoom: 19
            });

            const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '&copy; Esri',
                maxZoom: 19
            });

            const darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
                maxZoom: 19
            });

            osmLayer.addTo(map);

            L.control.layers({
                'Street': osmLayer,
                'Satellite': satelliteLayer,
                'Dark': darkLayer
            }).addTo(map);

            gridSquares.addTo(map);

            // Geolocation
            if ("geolocation" in navigator) {
                navigator.geolocation.watchPosition(updateLocation, handleLocationError, {
                    enableHighAccuracy: true,
                    maximumAge: 30000,
                    timeout: 27000
                });
            } else {
                showToast("Geolocation not supported by this browser", 5000);
            }

            // Update grid overlay when map moves (debounced)
            map.on('moveend', debounce(updateGridOverlay, 150));

            updateGridOverlay();
        }

        function updateLocation(position) {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;

            if (!marker) {
                marker = L.circleMarker([lat, lon], {
                    radius: 8,
                    fillColor: '#4285F4',
                    fillOpacity: 1,
                    color: '#fff',
                    weight: 3
                }).addTo(map);
            } else {
                marker.setLatLng([lat, lon]);
            }

            if (!firstFix) {
                firstFix = true;
                map.setView([lat, lon], 10);
            }

            const gridSquare = calculateGridSquare(lat, lon, true);
            document.getElementById('grid-text').textContent = `Current Grid: ${gridSquare}`;
        }

        function handleLocationError(error) {
            showToast(`Location: ${error.message}`, 4000);
        }

        function updateGridOverlay() {
            gridSquares.clearLayers();
            const bounds = map.getBounds();
            const zoom = map.getZoom();
            const showSubsquares = zoom >= 11;
            const showExtended = zoom >= 14;

            let precisionText;
            if (showExtended) {
                precisionText = "Showing 8-char extended (30\" x 15\")";
            } else if (showSubsquares) {
                precisionText = "Showing 6-char subsquares (5' x 2.5')";
            } else {
                precisionText = "Showing 4-char fields (2\u00B0 x 1\u00B0)";
            }
            document.getElementById('precision-display').textContent = precisionText;

            const south = Math.max(bounds.getSouth(), -90);
            const north = Math.min(bounds.getNorth(), 90);

            // Compute iteration edges in degrees, snapped to 2-degree lon / 1-degree lat grid
            const westEdge = Math.floor((bounds.getWest() + 180) / 2) * 2 - 180;
            const eastEdge = Math.ceil((bounds.getEast() + 180) / 2) * 2 - 180;
            const southEdge = Math.floor(south + 90) - 90;
            const northEdge = Math.ceil(north + 90) - 90;

            // Safety: limit total grid squares rendered
            const maxSquares = showExtended ? 2000 : 500;
            const lonSteps = Math.ceil((eastEdge - westEdge) / 2);
            const latSteps = Math.ceil(northEdge - southEdge);
            if (lonSteps * latSteps > maxSquares) return;

            for (let lon = westEdge; lon < eastEdge; lon += 2) {
                for (let lat = southEdge; lat < northEdge; lat += 1) {
                    // Normalize longitude for grid encoding (handles antimeridian)
                    const normLon = ((lon % 360) + 540) % 360 - 180;
                    const grid = calculateGridSquare(lat + 0.5, normLon + 1);
                    drawGridSquare(grid.substring(0, 4), 4, bounds);

                    if (showSubsquares) {
                        // Only iterate over subsquares that are actually visible
                        const subWidth = 5 / 60;
                        const subHeight = 2.5 / 60;
                        const gridWest = normLon;
                        const gridSouth = lat;

                        const startI = Math.max(0, Math.floor((bounds.getWest() - lon) / subWidth));
                        const endI = Math.min(24, Math.ceil((bounds.getEast() - lon) / subWidth));
                        const startJ = Math.max(0, Math.floor((bounds.getSouth() - lat) / subHeight));
                        const endJ = Math.min(24, Math.ceil((bounds.getNorth() - lat) / subHeight));

                        for (let i = startI; i < endI; i++) {
                            for (let j = startJ; j < endJ; j++) {
                                const centerLon = gridWest + (i * subWidth) + (subWidth / 2);
                                const centerLat = gridSouth + (j * subHeight) + (subHeight / 2);
                                const subGrid = calculateGridSquare(centerLat, centerLon);
                                drawGridSquare(subGrid, 6, bounds);

                                if (showExtended) {
                                    const extWidth = 30 / 3600;
                                    const extHeight = 15 / 3600;
                                    const extWest = gridWest + (i * subWidth);
                                    const extSouth = gridSouth + (j * subHeight);

                                    const extStartI = Math.max(0, Math.floor((bounds.getWest() - extWest) / extWidth));
                                    const extEndI = Math.min(10, Math.ceil((bounds.getEast() - extWest) / extWidth));
                                    const extStartJ = Math.max(0, Math.floor((bounds.getSouth() - extSouth) / extHeight));
                                    const extEndJ = Math.min(10, Math.ceil((bounds.getNorth() - extSouth) / extHeight));

                                    for (let ei = extStartI; ei < extEndI; ei++) {
                                        for (let ej = extStartJ; ej < extEndJ; ej++) {
                                            const extCenterLon = extWest + (ei * extWidth) + (extWidth / 2);
                                            const extCenterLat = extSouth + (ej * extHeight) + (extHeight / 2);
                                            const extGrid = calculateGridSquare(extCenterLat, extCenterLon, true);
                                            drawGridSquare(extGrid, 8, bounds);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        window.onload = initMap;
    </script>
</body>

</html>
